<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>VRM Viewer VR</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #fileInput {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 11;
            background: rgba(255,255,255,0.95);
            padding: 8px;
            border-radius: 6px;
            font-size: 14px;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 11;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div id="fileInput">
        <input type="file" id="file" accept=".vrm" />
    </div>
    <div id="info">Keine VRM geladen</div>

    <script type="module">
        import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.163/build/three.module.js";
        import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.163/examples/jsm/controls/OrbitControls.js";
        import { VRButton } from "https://cdn.jsdelivr.net/npm/three@0.163/examples/jsm/webxr/VRButton.js";
        import { VRMLoader } from "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.0.6/lib/three-vrm.module.js";

        let scene, camera, renderer, controls;
        let currentVRM = null;
        let vrmBlobUrl = null;
        const vrmLoader = new VRMLoader();
        const infoEl = document.getElementById("info");

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 200);
            camera.position.set(0, 1.6, 2);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            renderer.xr.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;

            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1.4, 0);
            controls.update();

            // Helpers for debugging / orientation
            const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            scene.add(grid);
            const axes = new THREE.AxesHelper(0.6);
            scene.add(axes);

            // Lights
            const dir = new THREE.DirectionalLight(0xffffff, 1.4);
            dir.position.set(1, 2, 1);
            scene.add(dir);

            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemi);

            window.addEventListener("resize", onWindowResize);
            document.getElementById("file").addEventListener("change", loadVRM);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        async function loadVRM(event) {
            const file = event.target.files && event.target.files[0];
            if (!file) return;

            console.log("Selected file:", file.name, file.size);
            infoEl.textContent = "Lade VRM: " + file.name;

            // Dispose previous
            if (currentVRM) {
                disposeCurrentVRM();
                currentVRM = null;
            }
            if (vrmBlobUrl) {
                try { URL.revokeObjectURL(vrmBlobUrl); } catch (_) {}
                vrmBlobUrl = null;
            }

            vrmBlobUrl = URL.createObjectURL(file);

            try {
                const vrm = await vrmLoader.loadAsync(vrmBlobUrl);
                console.log("VRM loaded:", vrm);
                try { URL.revokeObjectURL(vrmBlobUrl); } catch (_) {}
                vrmBlobUrl = null;

                currentVRM = vrm;

                // Add to scene
                if (currentVRM.scene) {
                    // Some VRMs include an offset; ensure we start from clean transform
                    currentVRM.scene.position.set(0, 0, 0);
                    currentVRM.scene.rotation.set(0, Math.PI, 0); // face forward
                    scene.add(currentVRM.scene);

                    // ensure meshes cast/receive shadows where applicable
                    currentVRM.scene.traverse((c) => {
                        if (c.isMesh) {
                            c.castShadow = true;
                            c.receiveShadow = true;
                        }
                    });

                    // compute bounding box and frame camera
                    frameModel(currentVRM.scene);
                    infoEl.textContent = "VRM geladen: " + file.name;
                } else {
                    console.warn("Geladenes VRM hat keine scene");
                    infoEl.textContent = "VRM geladen, aber keine scene gefunden";
                }
            } catch (err) {
                console.error("Fehler beim Laden der VRM-Datei:", err);
                infoEl.textContent = "Fehler beim Laden: " + (err && err.message ? err.message : err);
                alert("Fehler beim Laden der VRM-Datei. Öffne die Konsole für Details.");
            }
        }

        function frameModel(object3d) {
            // Compute bounding box in world space
            const box = new THREE.Box3().setFromObject(object3d);
            if (!box.isEmpty()) {
                const size = new THREE.Vector3();
                box.getSize(size);
                const center = new THREE.Vector3();
                box.getCenter(center);

                console.log("BoundingBox size:", size, "center:", center);

                // Set controls target to model center
                controls.target.copy(center);
                controls.update();

                // Position camera so the model fits
                const maxDim = Math.max(size.x, size.y, size.z);
                // distance factor (tweak if necessary)
                const fov = camera.fov * (Math.PI / 180);
                let distance = (maxDim / 2) / Math.tan(fov / 2);
                distance *= 1.5; // add padding

                // Place camera along its current forward direction relative to center
                const dir = new THREE.Vector3(0, 0, 1);
                dir.applyQuaternion(camera.quaternion);
                const camPos = center.clone().add(new THREE.Vector3(0, Math.max(1.0, size.y * 0.5), distance));
                camera.position.copy(camPos);
                camera.lookAt(center);
                camera.updateProjectionMatrix();

                console.log("Camera positioned at", camera.position);
            } else {
                console.warn("BoundingBox leer — kann Modell nicht framen.");
            }
        }

        function disposeCurrentVRM() {
            if (!currentVRM) return;
            try {
                if (currentVRM.scene && scene) scene.remove(currentVRM.scene);
                // dispose geometries/materials
                currentVRM.scene.traverse((node) => {
                    if (node.isMesh) {
                        if (node.geometry) node.geometry.dispose();
                        if (node.material) {
                            const mat = node.material;
                            if (Array.isArray(mat)) {
                                mat.forEach(m => disposeMaterial(m));
                            } else {
                                disposeMaterial(mat);
                            }
                        }
                    }
                });
            } catch (e) {
                console.warn("Fehler beim Freigeben früherer VRM-Ressourcen:", e);
            }
        }

        function disposeMaterial(material) {
            if (!material) return;
            // try to dispose textures
            for (const key in material) {
                const value = material[key];
                if (value && typeof value === "object" && "minFilter" in value) {
                    try { value.dispose(); } catch (_) {}
                }
            }
            try { material.dispose(); } catch (_) {}
        }

        let lastTime = null;
        function animate() {
            renderer.setAnimationLoop((time) => {
                if (lastTime === null) lastTime = time;
                const delta = Math.min(0.1, (time - lastTime) / 1000);
                lastTime = time;

                if (currentVRM && typeof currentVRM.update === "function") {
                    try { currentVRM.update(delta); } catch (_) {}
                }

                renderer.render(scene, camera);
            });
        }

        // Debug help: print any runtime errors to console
        window.addEventListener('error', (e) => {
            console.error("Window error:", e.error || e.message || e);
        });
    </script>
</body>
</html>
