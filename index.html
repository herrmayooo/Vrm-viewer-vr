<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <title>VRM Viewer VR — Debug (load button)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        html,body { height:100%; margin:0; }
        body { font-family: Arial, sans-serif; overflow: hidden; }
        #ui {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 50;
            width: 380px;
            max-height: calc(100vh - 16px);
            background: rgba(0,0,0,0.78);
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            box-sizing: border-box;
            overflow: hidden;
        }
        #controls { margin-bottom:8px; display:flex; gap:6px; align-items:center; }
        #file { flex:1; }
        #log {
            background: rgba(255,255,255,0.03);
            border-radius:6px;
            padding:8px;
            height: 55vh;
            overflow:auto;
            font-size: 12px;
            line-height:1.3;
        }
        #log .err { color:#ff9b9b; }
        #log .ok { color:#9bffb2; }
        #log .meta { color:#ccc; font-size: 11px; }
        #actions { margin-top:8px; display:flex; gap:8px; }
        button { padding:6px; border-radius:6px; border: none; cursor: pointer; background:#333; color:white; }
        button.primary { background:#2a9df4; }
        button.warn { background:#f48b2a; }
        #urlRow { display:flex; gap:6px; margin-top:6px; }
        input[type="text"] { flex:1; padding:6px; border-radius:6px; border:1px solid #444; background:#111; color:#fff; }
        .hint { font-size:12px; color:#ddd; margin-top:6px; }
    </style>
</head>
<body>
    <div id="ui" role="region" aria-label="VRM Debug UI">
        <div id="controls">
            <input id="file" type="file" accept=".vrm" />
            <button id="loadSelected" class="primary">Load selected file</button>
        </div>

        <div id="urlRow">
            <input id="urlInput" type="text" placeholder="Optional: URL zu einer VRM (https://...)" />
            <button id="loadUrl">Load URL</button>
        </div>

        <div class="hint">Wähle eine Datei und tippe danach auf "Load selected file". Wenn die Log-Box keine Dateien sieht, poste den Log hier.</div>

        <div id="log" aria-live="polite">
            <div class="meta">Status: Warten auf Datei-Auswahl</div>
        </div>

        <div id="actions" style="margin-top:8px;">
            <button id="clear">Log löschen</button>
            <button id="copy">Log kopieren</button>
            <button id="test" class="warn">Test createObjectURL</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.163/build/three.module.js";
        import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.163/examples/jsm/controls/OrbitControls.js";
        import { VRButton } from "https://cdn.jsdelivr.net/npm/three@0.163/examples/jsm/webxr/VRButton.js";
        import { VRMLoader } from "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.0.6/lib/three-vrm.module.js";

        // three.js basics
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 200);
        camera.position.set(0, 1.6, 2);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.xr.enabled = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.4, 0);
        controls.update();
        scene.add(new THREE.GridHelper(10, 10, 0x444444, 0x222222));
        scene.add(new THREE.AxesHelper(0.6));
        scene.add(new THREE.DirectionalLight(0xffffff, 1.2));
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // UI refs
        const fileInput = document.getElementById('file');
        const loadSelectedBtn = document.getElementById('loadSelected');
        const urlInput = document.getElementById('urlInput');
        const loadUrlBtn = document.getElementById('loadUrl');
        const logEl = document.getElementById('log');
        const clearBtn = document.getElementById('clear');
        const copyBtn = document.getElementById('copy');
        const testBtn = document.getElementById('test');

        function appendLog(text, cls) {
            const d = document.createElement('div');
            d.textContent = text;
            if (cls) d.className = cls;
            logEl.prepend(d);
        }
        function setStatus(text) {
            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.textContent = 'Status: ' + text;
            logEl.prepend(meta);
        }

        clearBtn.addEventListener('click', () => { logEl.innerHTML = ''; setStatus('Log gelöscht'); });
        copyBtn.addEventListener('click', () => {
            const txt = logEl.innerText || logEl.textContent;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(txt).then(() => setStatus('Log kopiert'), (e) => appendLog('Clipboard Fehler: '+e, 'err'));
            } else {
                window.prompt('Copy the log below', txt);
            }
        });

        // detect file input events
        fileInput.addEventListener('change', (e) => {
            appendLog('file input "change" event fired', 'meta');
            logFileList();
        });
        fileInput.addEventListener('input', (e) => {
            appendLog('file input "input" event fired', 'meta');
            logFileList();
        });
        fileInput.addEventListener('click', (e) => {
            appendLog('file input "click" event fired (user opened picker?)', 'meta');
        });

        function logFileList() {
            const files = fileInput.files;
            if (!files) {
                appendLog('fileInput.files is null/undefined', 'err');
                return;
            }
            appendLog('fileInput.files.length = ' + files.length, 'meta');
            for (let i = 0; i < files.length; i++) {
                const f = files[i];
                appendLog(' - ['+i+'] ' + f.name + ' (' + Math.round(f.size/1024) + ' KB) type=' + (f.type || 'n/a'), 'meta');
            }
            if (files.length === 0) setStatus('Keine Datei im input vorhanden');
            else setStatus(files.length + ' Datei(en) ausgewählt');
        }

        // allow manual load of selected file (useful on browsers that don't fire change reliably)
        loadSelectedBtn.addEventListener('click', () => {
            appendLog('Load selected file button clicked', 'meta');
            const f = fileInput.files && fileInput.files[0];
            if (!f) {
                appendLog('Kein File im input gefunden — tippe Datei an und dann Load selected file', 'err');
                setStatus('Keine Datei zum Laden');
                return;
            }
            appendLog('Lade Datei per Button: ' + f.name, 'meta');
            handleFile(f);
        });

        // Load from remote URL (for quick testing)
        loadUrlBtn.addEventListener('click', async () => {
            const url = (urlInput.value || '').trim();
            if (!url) { appendLog('Keine URL eingegeben', 'err'); return; }
            appendLog('Versuche Datei von URL zu laden: ' + url);
            setStatus('Lade URL: ' + url);
            try {
                const res = await fetch(url);
                if (!res.ok) { appendLog('Fetch failed: ' + res.status + ' ' + res.statusText, 'err'); setStatus('Fetch Fehler'); return; }
                const buf = await res.arrayBuffer();
                const blob = new Blob([buf]);
                const file = new File([blob], url.split('/').pop() || 'remote.vrm', { type: 'application/octet-stream' });
                appendLog('Remote-Datei heruntergeladen (' + buf.byteLength + ' bytes)', 'meta');
                handleFile(file);
            } catch (e) {
                appendLog('Fetch error: ' + (e && e.message ? e.message : e), 'err');
                setStatus('Fetch Fehler');
            }
        });

        testBtn.addEventListener('click', () => {
            try {
                const b = new Blob(['hi']);
                const u = URL.createObjectURL(b);
                appendLog('createObjectURL ok: ' + u, 'meta');
                URL.revokeObjectURL(u);
                appendLog('revokeObjectURL ok', 'meta');
                setStatus('createObjectURL ok');
            } catch (e) {
                appendLog('createObjectURL Fehler: ' + (e && e.message ? e.message : e), 'err');
                setStatus('createObjectURL Fehler');
            }
        });

        // VRM loader & logic (same logic as before)
        const vrmLoader = new VRMLoader();
        let currentVRM = null;
        let vrmBlobUrl = null;

        async function handleFile(file) {
            appendLog('handleFile: ' + file.name + ' (' + Math.round(file.size/1024) + ' KB)', 'meta');
            setStatus('Lade VRM: ' + file.name);

            // dispose previous
            if (currentVRM) {
                try { if (currentVRM.scene) scene.remove(currentVRM.scene); } catch(_) {}
                currentVRM = null;
                appendLog('Vorheriges VRM entfernt', 'meta');
            }
            if (vrmBlobUrl) { try { URL.revokeObjectURL(vrmBlobUrl); } catch(_) {} vrmBlobUrl = null; }

            // Read header and try strategies
            try {
                const buf = await file.arrayBuffer();
                appendLog('ArrayBuffer gelesen (' + buf.byteLength + ' bytes)', 'meta');

                // create blob url if possible
                try {
                    vrmBlobUrl = URL.createObjectURL(file);
                    appendLog('Blob-URL erstellt: ' + vrmBlobUrl, 'meta');
                } catch (e) {
                    appendLog('createObjectURL fehlgeschlagen: ' + (e && e.message ? e.message : e), 'err');
                    vrmBlobUrl = null;
                }

                // Try loadAsync first
                if (vrmBlobUrl) {
                    try {
                        appendLog('Versuche vrmLoader.loadAsync(blobUrl) ...');
                        const vrm = await vrmLoader.loadAsync(vrmBlobUrl);
                        appendLog('loadAsync erfolgreich', 'ok');
                        try { URL.revokeObjectURL(vrmBlobUrl); } catch(_) {}
                        vrmBlobUrl = null;
                        handleLoadedVRM(vrm, file.name);
                        return;
                    } catch (e) {
                        appendLog('loadAsync Fehler: ' + (e && e.message ? e.message : e), 'err');
                    }
                } else {
                    appendLog('kein blob url — überspringe loadAsync', 'meta');
                }

                // Fallback parse
                try {
                    appendLog('Versuche vrmLoader.parse(ArrayBuffer) ...');
                    await parseWithLoader(buf, file.name);
                    return;
                } catch (e) {
                    appendLog('parse Fehler: ' + (e && e.message ? e.message : e), 'err');
                }

                // fallback fetch(blob) -> parse
                if (vrmBlobUrl) {
                    try {
                        appendLog('Versuche fetch(blobUrl) und parse ...', 'meta');
                        const res = await fetch(vrmBlobUrl);
                        const ab = await res.arrayBuffer();
                        appendLog('fetch success, bytes: ' + ab.byteLength, 'meta');
                        await parseWithLoader(ab, file.name);
                        try { URL.revokeObjectURL(vrmBlobUrl); } catch(_) {}
                        vrmBlobUrl = null;
                        return;
                    } catch (e) {
                        appendLog('fetch+parse Fehler: ' + (e && e.message ? e.message : e), 'err');
                    } finally {
                        try { URL.revokeObjectURL(vrmBlobUrl); } catch(_) {}
                        vrmBlobUrl = null;
                    }
                }

                appendLog('Alle Ladewege gescheitert', 'err');
                setStatus('Keine VRM geladen');
            } catch (e) {
                appendLog('Fehler beim Lesen der Datei: ' + (e && e.message ? e.message : e), 'err');
                setStatus('Fehler beim Lesen');
            }
        }

        function parseWithLoader(arrayBuffer, filename) {
            return new Promise((resolve, reject) => {
                try {
                    vrmLoader.parse(arrayBuffer, '', (vrm) => {
                        appendLog('vrmLoader.parse erfolgreich', 'ok');
                        handleLoadedVRM(vrm, filename);
                        resolve(vrm);
                    }, (err) => {
                        reject(err || new Error('parse callback error'));
                    });
                } catch (ex) {
                    reject(ex);
                }
            });
        }

        function handleLoadedVRM(vrm, filename) {
            try { appendLog('Loaded object keys: ' + Object.keys(vrm).join(', '), 'meta'); } catch (_) {}
            const sceneObj = (vrm && (vrm.scene || vrm.sceneGraph)) || null;
            if (!sceneObj) {
                appendLog('Geladenes Objekt hat keine scene-Eigenschaft! Keys: ' + Object.keys(vrm).join(', '), 'err');
                currentVRM = vrm;
                setStatus('Geladen, aber keine scene gefunden');
                return;
            }
            sceneObj.position.set(0,0,0);
            sceneObj.rotation.set(0, Math.PI, 0);
            scene.add(sceneObj);
            currentVRM = vrm;
            sceneObj.traverse((c) => {
                if (c.isMesh) {
                    c.castShadow = true; c.receiveShadow = true;
                    if (c.material) c.material.needsUpdate = true;
                }
            });
            appendLog('VRM in Szene hinzugefügt: ' + filename, 'ok');
            // bounding box
            try {
                const box = new THREE.Box3().setFromObject(sceneObj);
                if (box.isEmpty()) {
                    appendLog('BoundingBox ist leer (keine Geometrie gefunden?)', 'err');
                } else {
                    const size = new THREE.Vector3(); box.getSize(size);
                    const center = new THREE.Vector3(); box.getCenter(center);
                    appendLog('BoundingBox center=' + center.toArray().map(n => n.toFixed(2)).join(', ') + ' size=' + size.toArray().map(n => n.toFixed(2)).join(', '), 'meta');
                    controls.target.copy(center); controls.update();
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let distance = (maxDim / 2) / Math.tan(fov / 2);
                    distance *= 1.6;
                    const camPos = center.clone().add(new THREE.Vector3(0, Math.max(1.0, size.y*0.5), distance));
                    camera.position.copy(camPos);
                    camera.lookAt(center);
                    camera.updateProjectionMatrix();
                    appendLog('Kamera positioniert', 'meta');
                }
            } catch (e) {
                appendLog('BoundingBox Fehler: ' + (e && e.message ? e.message : e), 'err');
            }
            setStatus('VRM geladen: ' + filename);
        }

        // render loop
        let lastTime = null;
        function animateLoop() {
            renderer.setAnimationLoop((t) => {
                if (lastTime === null) lastTime = t;
                const dt = Math.min(0.1, (t - lastTime) / 1000);
                lastTime = t;
                if (currentVRM && typeof currentVRM.update === 'function') {
                    try { currentVRM.update(dt); } catch (_) {}
                }
                renderer.render(scene, camera);
            });
        }
        animateLoop();

        // show window errors in overlay
        window.addEventListener('error', (e) => {
            appendLog('Window error: ' + (e && e.error && e.error.message ? e.error.message : (e && e.message ? e.message : 'unknown')), 'err');
            setStatus('Window error');
        });
        window.addEventListener('unhandledrejection', (ev) => {
            appendLog('UnhandledRejection: ' + (ev && ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason)), 'err');
            setStatus('Unhandled rejection');
        });
    </script>
</body>
</html>
