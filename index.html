<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>VRM Viewer — Quick Debug</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0}
    body{font-family:Arial,Helvetica,sans-serif;background:#111;color:#eee;overflow:hidden}
    #ui{position:absolute;left:10px;top:10px;width:380px;background:rgba(0,0,0,0.8);padding:10px;border-radius:8px;z-index:50}
    #ui h1{font-size:14px;margin:0 0 8px 0}
    #controls{display:flex;gap:6px;margin-bottom:8px}
    input[type=file]{flex:1}
    button{background:#2b2b2b;border:1px solid #333;color:#eee;padding:6px;border-radius:6px;cursor:pointer}
    button.primary{background:#2a9df4}
    button.success{background:#3bbf7c}
    #log{background:#0b0b0b;border:1px solid #222;padding:8px;height:56vh;overflow:auto;font-size:12px;line-height:1.3;border-radius:6px}
    .meta{color:#9aa}
    .ok{color:#6f6}
    .err{color:#f88}
    .small{font-size:12px;color:#aaa;margin-top:6px}
    #canvasWrap{position:fixed;right:0;top:0;bottom:0;left:420px;background:#222}
    canvas{width:100%;height:100%;display:block}
  </style>
</head>
<body>
  <div id="ui" role="region" aria-label="VRM Debug UI">
    <h1>VRM Quick Debug</h1>

    <div id="controls">
      <input id="fileInput" type="file" accept=".vrm" />
      <button id="loadSelected" class="primary">Load selected file</button>
    </div>

    <div style="display:flex;gap:6px;margin-bottom:8px">
      <button id="systemPicker">System‑Picker</button>
      <button id="testBlob">Test createObjectURL</button>
      <button id="copyLog" class="success">Log kopieren</button>
    </div>

    <div id="log" aria-live="polite">
      <div class="meta">Status: bereit</div>
    </div>

    <div class="small">Anleitung: Datei auswählen → dann "Load selected file" drücken. Wenn nichts passiert: System‑Picker probieren. Log kopieren und hier posten.</div>
  </div>

  <div id="canvasWrap"></div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.163/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.163/examples/jsm/controls/OrbitControls.js";
    import { VRButton } from "https://cdn.jsdelivr.net/npm/three@0.163/examples/jsm/webxr/VRButton.js";
    import { VRMLoader } from "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.0.6/lib/three-vrm.module.js";

    // UI
    const fileInput = document.getElementById('fileInput');
    const loadSelectedBtn = document.getElementById('loadSelected');
    const systemPickerBtn = document.getElementById('systemPicker');
    const testBlobBtn = document.getElementById('testBlob');
    const copyLogBtn = document.getElementById('copyLog');
    const logEl = document.getElementById('log');

    function log(text, cls) {
      const d = document.createElement('div');
      d.textContent = text;
      if (cls) d.className = cls;
      logEl.prepend(d);
    }
    function status(text) {
      const m = document.createElement('div');
      m.className = 'meta';
      m.textContent = 'Status: ' + text;
      logEl.prepend(m);
    }

    // show some environment info
    status('ready');
    log('UserAgent: ' + navigator.userAgent, 'meta');
    log('showOpenFilePicker supported: ' + (typeof window.showOpenFilePicker === 'function'), 'meta');

    // three.js minimal canvas so you can at least see background
    const canvasWrap = document.getElementById('canvasWrap');
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth - 420, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    canvasWrap.appendChild(renderer.domElement);
    // scene simple
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    const camera = new THREE.PerspectiveCamera(60, (window.innerWidth - 420) / window.innerHeight, 0.01, 200);
    camera.position.set(0,1.6,2);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,1.4,0);
    controls.update();
    scene.add(new THREE.HemisphereLight(0xffffff,0x444444,0.6));
    scene.add(new THREE.DirectionalLight(0xffffff,1.0).position.set(1,2,1));
    scene.add(new THREE.GridHelper(4,4,0x444444,0x222222));
    window.addEventListener('resize', ()=> {
      renderer.setSize(window.innerWidth - 420, window.innerHeight);
      camera.aspect = (window.innerWidth - 420) / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // VRM loader (we only log events here for now)
    const vrmLoader = new VRMLoader();
    let currentVRM = null;
    let vrmBlobUrl = null;

    // file input events
    fileInput.addEventListener('click', () => log('file input clicked', 'meta'));
    fileInput.addEventListener('change', (e) => {
      log('file input change event fired', 'meta');
      logFileList();
    });
    fileInput.addEventListener('input', () => {
      log('file input input event fired', 'meta');
      logFileList();
    });

    function logFileList() {
      const files = fileInput.files;
      if (!files) {
        log('fileInput.files is null/undefined', 'err'); return;
      }
      log('fileInput.files.length = ' + files.length, 'meta');
      for (let i=0;i<files.length;i++){
        const f = files[i];
        log('['+i+'] ' + f.name + ' (' + Math.round(f.size/1024) + ' KB) type=' + (f.type||'n/a'), 'meta');
      }
      if (files.length === 0) status('keine Datei im input vorhanden');
      else status(files.length + ' Datei(en) ausgewählt');
    }

    // manual load selected file button
    loadSelectedBtn.addEventListener('click', async () => {
      log('Load selected file button clicked', 'meta');
      const f = fileInput.files && fileInput.files[0];
      if (!f) { log('Kein File im input gefunden — Datei angetippt? Wenn nicht, System‑Picker probieren.', 'err'); status('keine Datei'); return; }
      log('Lade Datei per Button: ' + f.name, 'meta');
      await tryLoadFile(f);
    });

    // system picker
    systemPickerBtn.addEventListener('click', async () => {
      log('System‑Picker button clicked', 'meta');
      if (!window.showOpenFilePicker) { log('showOpenFilePicker nicht unterstützt', 'err'); status('Kein System‑Picker'); return; }
      try {
        const [handle] = await window.showOpenFilePicker({ multiple:false, types:[{description:'VRM', accept:{'model/gltf-binary':['.vrm','.glb']}}] });
        const file = await handle.getFile();
        log('System‑Picker lieferte: ' + file.name, 'meta');
        await tryLoadFile(file);
      } catch (e) {
        log('System‑Picker abgebrochen / Fehler: ' + (e && e.message? e.message : e), 'err');
        status('Picker abgebrochen');
      }
    });

    testBlobBtn.addEventListener('click', () => {
      try {
        const b = new Blob(['hi']);
        const u = URL.createObjectURL(b);
        log('createObjectURL OK: ' + u, 'ok');
        URL.revokeObjectURL(u);
        log('revokeObjectURL OK', 'ok');
        status('Blob API OK');
      } catch (e) {
        log('createObjectURL Fehler: ' + (e && e.message? e.message : e), 'err');
        status('Blob API Fehler');
      }
    });

    copyLogBtn.addEventListener('click', async () => {
      const txt = logEl.innerText || logEl.textContent;
      try {
        await navigator.clipboard.writeText(txt);
        status('Log in Zwischenablage');
      } catch (e) {
        log('Clipboard write failed: ' + e, 'err');
        window.prompt('Copy log', txt);
      }
    });

    async function tryLoadFile(file) {
      status('Lese Datei: ' + file.name);
      try {
        // debug read
        const arr = await file.arrayBuffer();
        log('ArrayBuffer gelesen (' + arr.byteLength + ' bytes)', 'meta');

        // create blob url
        try {
          vrmBlobUrl = URL.createObjectURL(file);
          log('Blob-URL erstellt: ' + vrmBlobUrl, 'meta');
        } catch (e) {
          log('createObjectURL failed: ' + (e && e.message ? e.message : e), 'err');
          vrmBlobUrl = null;
        }

        // Try parse directly (safe)
        try {
          log('Versuche vrmLoader.parse(arrayBuffer) ...');
          await new Promise((resolve, reject) => {
            vrmLoader.parse(arr, '', (vrm) => { resolve(vrm); }, (err) => reject(err));
          });
          log('parse OK (VRM wahrscheinlich gültig)', 'ok');
          status('VRM lesbar (parse OK) — Model wird noch nicht dargestellt in Debug'); 
        } catch (e) {
          log('parse Fehler: ' + (e && e.message ? e.message : e), 'err');
          status('parse Fehler');
        }

        // Also try loadAsync if blob url was created
        if (vrmBlobUrl) {
          try {
            log('Versuche vrmLoader.loadAsync(blobUrl) ...');
            const vrm = await vrmLoader.loadAsync(vrmBlobUrl);
            log('loadAsync erfolgreich, VRM geladen', 'ok');
            // if successful, add to scene
            if (vrm && vrm.scene) {
              // remove existing
              if (currentVRM && currentVRM.scene) scene.remove(currentVRM.scene);
              currentVRM = vrm;
              vrm.scene.rotation.y = Math.PI;
              scene.add(vrm.scene);
              status('VRM in Szene hinzugefügt: ' + file.name);
            } else {
              log('loadAsync returned object without .scene', 'err');
              status('Geladen aber keine scene');
            }
            try { URL.revokeObjectURL(vrmBlobUrl); } catch(_) {}
            vrmBlobUrl = null;
            return;
          } catch (e) {
            log('loadAsync Fehler: ' + (e && e.message ? e.message : e), 'err');
            status('loadAsync Fehler');
          }
        }

        // If none worked:
        log('Fertig mit Laden-Versuchen (siehe oben). Falls du weiterhin "Warten" siehst: poste das komplette Log hier.', 'meta');

      } catch (e) {
        log('Fehler beim Lesen der Datei: ' + (e && e.message ? e.message : e), 'err');
        status('Fehler');
      }
    }

    // render loop
    let last = null;
    renderer.setAnimationLoop((time) => {
      if (last === null) last = time;
      const dt = Math.min(0.1, (time - last) / 1000);
      last = time;
      if (currentVRM && typeof currentVRM.update === 'function') {
        try { currentVRM.update(dt); } catch (_) {}
      }
      renderer.render(scene, camera);
    });

    // global error handlers visible in UI
    window.addEventListener('error', (e) => log('Window error: ' + (e && e.error && e.error.message ? e.error.message : (e && e.message ? e.message : 'unknown')), 'err'));
    window.addEventListener('unhandledrejection', (ev) => log('UnhandledRejection: ' + (ev && ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason)), 'err'));

  </script>
</body>
</html>
